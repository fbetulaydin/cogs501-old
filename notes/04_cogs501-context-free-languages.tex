\documentclass[11pt]{article}

\usepackage[nohide,twocolumn]{ulecnot}
\usepackage{xyling}

\usepackage{tikz-qtree}


\pagestyle{fancy}
\lhead{Cogs 501 -- Linguistics and Formal Languages}
\chead{Context Free Grammars and Languages}
\rhead{Updated \it \today}
\lfoot{Umut \"Ozge}
\rfoot{Page \thepage/\pageref{LastPage}}
\setlength{\headheight}{13.6pt}

\begin{document}
\section{Introduction}

\ezimeti{
\item
Thus far we have mainly dealt with \textbf{language
recognizers}, which are devices to recognize whether a given string
belongs to a language or not.
\item There are also \textbf{language generators}, which generate all
and only the grammatical sentences of a language.
\item Let us look at the regular expression $a(a^* \cup b^*)b$ from
the generation perspective:
\begin{quote}
First output an $a$, then

either output a number of $a$'s or a number of $b$'s, then

output a $b$, and stop.

\end{quote}

\item Let's see a generator -- a context-free grammar -- for a tiny fragment of English:
\ezimeti{
\item[i.]
\sysm{S\ \imp\ NP\ +\ VP}
\item[ii.]
\sysm{NP\ \imp\ D\ +\ N}
\item[iii.]
\sysm{VP\ \imp\ V\ +\ NP}
\item[iv.]
\sysm{D\ \imp\ the}
\item[v.]
\sysm{N\ \imp\ man, ball, \text{etc.}}
\item[vi.]
\sysm{V\ \imp\ hit, took, \text{etc.}}
}

\item A \textbf{leftmost}\footnote{In every step of the derivation,
you expand the leftmost nonterminal in the current string. The notion
of \textbf{rightmost} derivation is defined similarly.} derivation of
the string \sysm{the\ + man\ +\ hit\ +\ the\ +\ ball}:
\ezimeti{
\item[]{\it Derivation}\hfill{\it Rules}
\item[]\sysm{S}\hfill\sysm{S\ \imp\ NP\ +\ VP}
\item[]\sysm{NP\ +\ VP}\hfill\sysm{NP\ \imp\ D\ +\ N}
\item[]\sysm{D\ + N\ +\ VP}\hfill\sysm{VP\ \imp\ V\ +\ NP}
\item[]\sysm{D\ + N\ +\ V\ +\ NP}\hfill\sysm{D\ \imp\ the}
\item[]\sysm{the\ + N\ +\ V\ +\ NP}\hfill\sysm{N\ \imp\ man}
\item[]\sysm{the\ + man\ +\ V\ +\ NP}\hfill\sysm{V\ \imp\ hit}
\item[]\sysm{the\ + man\ +\ hit\ +\ NP}\hfill\sysm{NP\ \imp\ D\ +\ N}
\item[]\sysm{the\ + man\ +\ hit\ +\ D\ +\ N}\hfill\sysm{D\ \imp\ the}
\item[]\sysm{the\ + man\ +\ hit\ +\ the\ +\ N}\hfill\sysm{N\ \imp\ ball}
\item[]\sysm{the\ + man\ +\ hit\ +\ the\ +\ ball}
}

\begin{center}
\fbox{
\Tree  [.S [.NP 
			[.D [.the ] ] [.N [.man ] ] 
	 		] 
			[.VP 
			[.V [.hit ] ] [.NP [.D [.the ] ] [.N [.ball ] ] ] 
			] 
]

% \Tree[.1]{
%           &          &          &\K{S}\B{drr}\B{dll} &          &          &          &        \\
%           & \K{NP}\B{dr}\B{dl}   &          &          &          &\K{VP}\B{dr}\B{dl}    &          &        \\
% \K{D}\B{d}     &          &\K{N}\B{d}     &          &\K{V}\B{d}     &          &\K{NP}\B{dr}\B{dl}    &        \\
% \K{the}   &          &\K{man}   &          &\K{hit}   &\K{D}\B{d}& &\K{N}\B{d}   \\
% 	          &          &          &          &          &\K{the}   &          &\K{ball}\\
% }
}
\end{center}

\item The parse tree (constituent structure) contains less information than
the derivation (Why? Check Example~\ref{exder}).
\item A terminal string \sysm{\sigma} covered by a single node \sysm{X} is a
constituent of type \sysm{X}.
\item The terminal string covered by the root node is the
\textbf{yield} of the parse tree.

\begin{uexercise}
Introduce new rules to the grammar so that it can handle modification of NPs and
VPs by PPs.
\end{uexercise}
}

\newpage

\section{Grammars, derivations, parse trees}

In this section we have a more formal look at the concepts we encountered in the
introduction.
	

\noindent\hrulefill
\begin{udefinition}

A \textbf{context-free grammar} $G$ is a quadruple $\langle
V_N,V_T,R,S\rangle$ where

\ezimeti{
\item[]$V_N$ is the set of \textbf{non-terminal} symbols,
\item[]$V_T$ is the set of \textbf{terminal} symbols,
\item[]$R$ is the set of \textbf{rules} each of the form $A \to x$,
where $A \in V_N$ and $x \in 
(V_N \cup V_T)^*$, 
\item[] $S \in V_N$ is the \textbf{start} symbol.
}

\ezimeti{
\item[]
A \textbf{step} in a \textbf{derivation} can be characterized as
follows. For any $u, v \in (V_N \cup V_T)^*$, we write $u \Rightarrow
v$ (and say $v$ is derived from $u$ in one step) if and only if there
are strings $x,y \in  (V_N \cup V_T)^*$ such that $u = xAy$, $v =
xty$, and the rule $A \to t$ is in $R$.
\item[]
We call a sequence of the form:
\begin{align*}
w_0\Rightarrow w_1 \Rightarrow w_2 \Rightarrow \cdots \Rightarrow w_n
\end{align*}
 a \textbf{derivation} of $w_n$  from $w_0$ in $n$ \textbf{steps},
 where $n \geq 0$. When $w_0 = S$, we say that $G$ \textbf{generates}
 $w_n$ in $n$ steps.
\item[] The language of a grammar $G$ is $L(G) = \setabs{w \in V_T^*}{w\text{ is generated by } G}$.
}
\qed

\noindent \hrulefill
\end{udefinition}



\noindent \hrulefill

\begin{uexample}\label{exder}
Let $G = \langle V_N,V_T,R,S\rangle$ where

\ezimeti{
\item[]$V_N = \crbr{S,A,B}$,
\item[]$V_T = \crbr{a,b}$,
\item[]$R = \crbr{S\imp B a B a B, B\imp b B, B \imp \epsilon}$,
\item[] $S$ is the \textbf{start} symbol.
}

In specifying a grammar it is customary to give only the rules. Given the
convention that start symbol is $S$, all the properties of the grammar are
recoverable from the rules. The above grammar would be given as:

\begin{align*}
& S\imp B a B a B \\
& B\imp b B \\
& B \imp \epsilon
\end{align*}

It should not be too difficult to see what language is generated by the grammar.
It is the set of strings in $\crbr{a,b}^*$ containing exactly two $a$'s. Now let us have a closer
look to the derivation of the string $abab$ by this grammar. Actually more than
one derivation is possible for the given grammar and the string. Here is one:

\begin{align*}
\begin{array}{l|c|c}
\text{Step} & \text{Current string} & \text{Rule applied}\\  \hline
0&S & \\
1&B a B a B & S\imp B a B a B\\
2&a B a B & B \imp \epsilon\\
3&a b B a B& B \imp b B\\
4&a b a B & B\imp \epsilon\\
5&a b a b B & B\imp b B\\
6&a b a b & B \imp \epsilon\\
\end{array}
\end{align*}

Observe that each step consists of \uterm{rewriting} exactly one non-terminal by
using exactly one rule. The order in which the non-terminals are re-written and
the order in which the rules with the same left-hand-side non-terminal -- rules
for $B$ for instance -- is left non-specified in the grammar. These decisions
are left to the mechanism which actually generates the strings. Therefore the
above derivation is not the only possible derivation. Here is another
one: 

\begin{align*}
\begin{array}{l|c|c}
\text{Step} & \text{Current string} & \text{Rule applied}\\  \hline
0&S & \\
1&B a B a B & S\imp B a B a B\\
2&a B a B & B \imp \epsilon\\
3&a b B a B& B \imp b B\\
4&a b B a b B & B\imp b B\\
5&a b B a b  & B\imp \epsilon\\
6&a b a b & B \imp \epsilon\\
\end{array}
\end{align*}

Both derivations correspond to the same \uterm{parse tree}:

\Tree [.S [.B [.$\epsilon$ ] ] [.a  ] [.B [.b ] [.B [.$\epsilon$ ] ] ] [.a ] [.B [.b ] [.B
[.$\epsilon$ ] ] ] ]

\qed

\noindent \hrulefill
\end{uexample}

\noindent In general, it is not guaranteed that for a given grammar and a
string all distinct derviations correspond to the same tree. The next example
provides a case. 

\noindent\hrulefill
\begin{uexample}
First the grammar:
\begin{align*}
& S \imp B a B\\
& B \imp b B\\
& B \imp B a B a B\\
& B \imp \epsilon
\end{align*}

The grammar generates all and only the strings in $\crbr{a,b}^*$ that has an odd
number of $a$'s. For the string $abbaa$, the following is one possible
derivation -- given in a more compact notation:

$$
S \Rightarrow B a B \Rightarrow a B \Rightarrow a B a B a B \Rightarrow a b B a
B a B \Rightarrow a b b B a B a B \Rightarrow a b b a B a B \Rightarrow a b b a
a B \Rightarrow a b b a a
$$
which results in the tree:

\Tree [.S [.B [.$\epsilon$ ] ] [.a ] 
[.B [.B [.b ] [.B [.b ] [.B [.$\epsilon$ ] ] ] ] 
[.a ] [.B [.$\epsilon$ ] ] [.a ] [.B [.$\epsilon$ ] ]		
]
]

\bigskip 

Now another derivation of the same string,
$$S \Rightarrow B a B \Rightarrow a B \Rightarrow a b B \Rightarrow a b B a B a B \Rightarrow 
a b b B a B a B \Rightarrow a b b a B a B \Rightarrow a b b a a B \Rightarrow a
b b a a 
$$
this time resulting in a different tree:

\Tree [.S [.B [.$\epsilon$ ] ] [.a ] [.B [.b ] [.B [.B [.b ] [.B [.$\epsilon$ ]
] ] [.a ] [.B [.$\epsilon$ ] ] [.a ] [.B [.$\epsilon$ ] ] ] ] ] 

\noindent {\bf Important note: } The notation we have been using for derivations
allows for some vagueness. For instance take the following intial steps of a
derivation: 
$$
S \Rightarrow B a B \Rightarrow B a B a B a B\ldots
$$
In the second step it is not clear
whether the initial or the final $B$ is rewritten as $B a B a B$. This is a crucial piece of
information as it affects the resulting parse tree. If you want to be explicit
about which symbol is meant to be rewritten in a derivation, you can either give
the corresponding tree, or you can indicate the particular symbol by some
notation. One  method would be to indicate the symbol to be rewritten in the
next step by an overhead dot: 

$$
S \Rightarrow B a \dot B \Rightarrow B a B a B a B\ldots
$$

\qed

\noindent\hrulefill
\end{uexample}


\begin{uexercise}
Write context-free grammars for the languages: 

\ezimeti{

\item[(a)]
$a(a^* \cup b^*)b$
\item[(b)]
$\setabs{ww^R}{w \in \{a,b\}^*}$
\item[(c)]
$\setabs{w \in \{a,b\}^*}{w=w^R}$
\item[(d)]
$\setabs{a^nb^ma^n}{n,m \geq 1}$
\item[(e)]
$\setabs{a^nb^na^mb^m}{n,m \geq 1}$
\item[(f)]
$\setabs{a^nb^mc^md^{2n}}{n,m \geq 1}$
\item[(g)]
$\setabs{a^nb^m}{0\leq n\leq m \leq 2n}$
\item[(h)]Set of strings with exactly two $b$'s.
\item[(i)] \ldots with at least two $b$'s.
\item[(j)] \ldots with an even length.
\item[(k)] \ldots with an even number of $b$'s. 
\item[(l)] \ldots with a positive even number of $b$'s.
}

\end{uexercise}

%\section{More on Derivations and Parse Trees}


\section{CFLs and Regular Languages (FALs)}

\ezimeti{

\item Not every context-free language is a regular language.
(We have already seen this through counterexamples.)

\item Every regular language is a context-free language (proof by
\emph{direct construction}).

\item \textbf{Direct Construction:} For any deterministic finite state machine $M=\langle
K,\Sigma,\delta,q_1,F\rangle$, you can construct a context-free grammar
$G_M= \langle K,\Sigma,R,q_0\rangle$ with
\begin{align*}
R=\setabs{q\to ap}{\delta(q,a) = p} \cup \setabs{q \to \epsilon}{q \in
F}
\end{align*}
such that $L(M)=L(G_M)$.

\item Such grammars are called \uterm{regular grammars}.
\item A regular language can  be generated by a non-regular but context-free
grammar.

}


\section{Closure Properties of CFLs}

\ezimeti{
\item[]{\bf Union:}
\item[] Given two context-free grammars $G_1=\langle V_{N_1},V_{T_1},R_1,S_1  \rangle$
and \\ $G_2=\langle V_{N_2},V_{T_2},R_2,S_2  \rangle$ form the grammar $G=\langle V_{N},V_{T},R,S \rangle$ in the
following way,
	\ezimeti{
	\item[i.] If the non-terminals of $G_1$	and $G_2$ are not disjoint, make them so
	(e.g.\ by putting primes to those of $G_2$).
	\item[ii.] Let  $R = \{S \imp S_1,S \imp S_2\}\cup R_1 \cup R_2$.
	}
\item[] $G$ will generate all and only the strings that are generated by $G_1$ or
$G_2$, or both, namely $L(G) = L(G_1) \cup L(G_2)$. Therefore, CFL's are closed under union. 


\item[]{\bf Concatenation:}
\item[] The method of constructing $G$ from $G_1$ and $G_2$ is the same except
that \\ $R = \{S \imp S_1S_2\}\cup R_1 \cup R_2$.

\item[]{\bf Kleene star:}
\item[] Given a context-free grammar $G=\langle V_{N},V_{T},R,S  \rangle$ one
can construct a grammar $G^\prime$ that generates $L(G)^*$ in the following way:
	\ezimeti{
	\item[i.] Let $S^\prime$ be the start symbol of $G^\prime$.
	\item[ii.] Let $R^\prime = \{S^\prime\imp S^\prime
	S,S^\prime\imp\epsilon\}\cup R$.
	}

\item CFLs are \emph{not} closed under \emph{intersection} and
\emph{complementation}.
\item Intersection of a CFL with a FAL is a CFL.
}

\end{document}
\newpage
\ 
\newpage

\section*{Solutions to selected exercises}


\begin{itemize}

\item[2.2a] 
\sysm{S \imp aTb}\\
\sysm{T \imp A}\\
\sysm{T \imp B}\\
\sysm{A \imp aA}\\
\sysm{B \imp bB}\\
\sysm{A \imp \epsilon}\\
\sysm{B \imp \epsilon}\\

\item[2.2b] 

\sysm{S \imp aSa}\\
\sysm{S \imp bSb}\\
\sysm{S \imp \epsilon}\\

\item[2.2c] 

\sysm{S \imp aSa \quad|\quad bSb \quad|\quad a \quad|\quad b\quad|\quad \epsilon}

\item[2.2d] 

\sysm{S \imp aSa \quad|\quad  aBa}\\
\sysm{B \imp bB \quad|\quad  b }

\item[2.2e] 

\sysm{S \imp AB}\\
\sysm{A \imp aAb \quad|\quad  ab }\\
\sysm{B \imp aBb \quad|\quad  ab }

\item[2.2f] 

\sysm{S \imp aSdd \quad|\quad  aCdd}\\
\sysm{C \imp bCc \quad|\quad  bc }

\item[2.2g] 

\sysm{S \imp aSb \quad|\quad  aSbb \quad|\quad  \epsilon}

\item[2.2h] 

\sysm{S \imp AbAbA}\\
\sysm{A \imp aA \quad|\quad  \epsilon}

\item[2.2i] 

\sysm{S \imp AbAbA}\\
\sysm{A \imp aA \quad|\quad  bA\quad|\quad  \epsilon}


\item[2.2j] 

\sysm{S \imp abS \quad|\quad  baS \quad|\quad  bbS \quad|\quad  aaS \quad|\quad  \epsilon}

\item[2.2k] 

\sysm{S \imp SbSbS \quad|\quad  aS \quad|\quad  \epsilon}

\item[2.2l] 

\sysm{S \imp AbAbA}\\
\sysm{A \imp AbAbA \quad|\quad  aA \quad|\quad  \epsilon}

\end{itemize}


\section{A Pumping Theorem}

Let $G$ be a context-free grammar $\langle V_N,V_T,R,S \rangle$,
then the \textbf{fanout} of $G$, denoted as $\phi(G)$, is the largest 
number of symbols on the right-hand side of any rule in $R$. 
Let a \textbf{path} in a parse tree be a sequence of distinct
nonterminals each connected to the previous one with a line segment;
the first node is the root and the last is a terminal symbol. 
The \textbf{height} of a parse tree is the length of the longest path in it.
Then the yield of any parse tree of $G$ of height $h$ cannot have a
length greater than $\phi(G)^h$.

\begin{utheorem}[Pumping Theorem for CFLs]
Let $G=\langle V_N,V_T,R,S \rangle$ be a context-free grammar. Then
any string $w$ of length greater than $\phi(G)^{V_N}$ can be rewritten
as $uvxyz$ in such a way that either $v$ or $y$ is nonempty and
$uv^nxy^nz$ is in $L(G)$ for every $n\geq 0$. 
\end{utheorem}


\question A \uterm{push-down automaton} is a finite state machine equipped with a
\uterm{push-down store}. A push-down store is a container for storing and retrieving
symbols. When you push a symbol into an empty store the symbol goes to the
bottom. When you push another symbol it goes right on top of the first, and so
on. Symbols are stored on top of each other in the order they are pushed into
the store. When it comes to taking a symbol out of the store, 
Therefore, you can only take out what you have put
in last, no access to symbols put in earlier.   




